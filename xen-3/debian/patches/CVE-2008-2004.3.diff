
# HG changeset patch
# User Keir Fraser <keir.fraser@citrix.com>
# Date 1210860689 -3600
# Node ID 0016f5a1dd5a1622bcc66b82d2ef9bf4d36e88e3
# Parent aee5dc4a4a37005994c9ea7e9eab73043f30cb2c
ioemu: Do not try to guess backing file format when using qcow vbds.
Signed-off-by: Ian Jackson <Ian.Jackson@eu.citrix.com>
xen-unstable changeset:   17646:e3b13e1ecf6ca61b84c8bdf5ae3e961268c920f5
xen-unstable date:        Thu May 15 15:10:05 2008 +0100

--- a/tools/ioemu/block.c	Thu May 15 09:59:19 2008 +0100
+++ b/tools/ioemu/block.c	Thu May 15 15:11:29 2008 +0100
@@ -236,8 +236,28 @@ static int is_windows_drive(const char *
 }
 #endif
 
+static int bdrv_invalid_protocol_open(BlockDriverState *bs,
+				      const char *filename, int flags) {
+    return -ENOENT;
+}
+
+static BlockDriver bdrv_invalid_protocol = {
+    "invalid_protocol",
+    .bdrv_open = bdrv_invalid_protocol_open,
+};
+
 static BlockDriver *find_protocol(const char *filename)
 {
+    /* Return values:
+     *   &bdrv_xxx
+     *      filename specifies protocol xxx
+     *      caller should use that
+     *   NULL                    filename does not specify any protocol
+     *       caller may apply their own default
+     *   &bdrv_invalid_protocol  filename speciies an unknown protocol
+     *       caller should return -ENOENT; or may just try to open with
+     *       that bdrv, which always fails that way.
+     */
     BlockDriver *drv1;
     char protocol[128];
     int len;
@@ -250,7 +270,7 @@ static BlockDriver *find_protocol(const 
 #endif
     p = strchr(filename, ':');
     if (!p)
-        return NULL; /* do not ever guess raw, it is a security problem! */
+        return NULL;
     len = p - filename;
     if (len > sizeof(protocol) - 1)
         len = sizeof(protocol) - 1;
@@ -261,7 +281,7 @@ static BlockDriver *find_protocol(const 
             !strcmp(drv1->protocol_name, protocol))
             return drv1;
     }
-    return NULL;
+    return &bdrv_invalid_protocol;
 }
 
 /* XXX: force raw format if block or character device ? It would
@@ -291,8 +311,8 @@ static BlockDriver *find_image_format(co
 #endif
     
     drv = find_protocol(filename);
-    /* no need to test disk image formats for vvfat */
-    if (drv == &bdrv_vvfat)
+    /* no need to test disk image format if the filename told us */
+    if (drv != NULL)
         return drv;
 
     ret = bdrv_file_open(&bs, filename, BDRV_O_RDONLY);
@@ -386,7 +406,7 @@ int bdrv_open2(BlockDriverState *bs, con
     if (flags & BDRV_O_FILE) {
         drv = find_protocol(filename);
         if (!drv)
-            return -ENOENT;
+	    drv = &bdrv_raw;
     } else {
         if (!drv) {
             drv = find_image_format(filename);
@@ -434,7 +454,7 @@ int bdrv_open2(BlockDriverState *bs, con
         }
         path_combine(backing_filename, sizeof(backing_filename),
                      filename, bs->backing_file);
-        if (bdrv_open(bs->backing_hd, backing_filename, 0) < 0)
+        if (bdrv_open2(bs->backing_hd, backing_filename, 0, &bdrv_raw) < 0)
             goto fail;
     }
 
--- a/tools/ioemu/xenstore.c	Thu May 15 09:59:19 2008 +0100
+++ b/tools/ioemu/xenstore.c	Thu May 15 15:11:29 2008 +0100
@@ -247,6 +247,8 @@ void xenstore_parse_domain_config(int do
 		    /* autoguess qcow vs qcow2 */
 		} else if (!strcmp(drv,"file") || !strcmp(drv,"phy")) {
 		    format = &bdrv_raw;
+		} else if (!strcmp(drv,"phy")) {
+		    format = &bdrv_raw;
 		} else {
 		    format = bdrv_find_format(drv);
 		    if (!format) {
@@ -256,7 +258,7 @@ void xenstore_parse_domain_config(int do
 		}
 	    }
             if (bdrv_open2(bs, params, 0 /* snapshot */, format) < 0)
-                fprintf(stderr, "qemu: could not open vbd '%s' or hard disk image '%s' (drv '%s')\n", buf, params, drv ? drv : "?");
+                fprintf(stderr, "qemu: could not open vbd '%s' or hard disk image '%s' (drv '%s' format '%s')\n", buf, params, drv ? drv : "?", format ? format->format_name : "0");
         }
     }
 

